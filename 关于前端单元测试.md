对于许多开发人员来说，测试前端代码仍然是一个令人困惑的实践。但是随着前端开发变得越来越复杂，开发人员前所未有地负责稳定性和一致性，前端测试必须作为一个平等的公民在你的代码库中接受。 我们分解你的不同测试选项，并解释什么情况下他们是最好的使用。  
前端测试是一个笼统的术语，涵盖了各种自动化测试策略。 其中的一些测试，比如单元测试和集成测试，多年来一直是后端开发社区中公认的最佳实践。
## 有哪些常见的测试类型? 
我们常说的前端测试主要包含以下三方面
  - 单元测试: 测试一段代码(通常是一个对象或函数) ，与其他部分隔离开来
  - 集成测试: 将多个部分放在一起进行测试
  - 验收测试(也称为功能测试) : 对整个应用程序进行自动测试，例如使用像 Selenium 这样的工具来自动运行浏览器
## 单元测试
单元测试是应用广泛的测试类型之一，它处于所有测试类型的最低级别。 其目的是确保您的代码的最小位(称为单元)按预期独立运行。通常是对象或模块中的一个函数。单元测试简单、编写快速、运行快速。 这意味着你可以有许多单元测试，更多的单元测试意味着可以捕获更多的错误。 如果你需要更改代码，它们特别有用: 当你有一组单元测试来验证代码的工作时，你可以安全地更改代码，并确保程序的其他部分不会出错。
举一个简单的例子：
```
function add(a,b){
  return a + b;
}
```
上面是一个add函数，他的功能是传入两个参数，他会返回两个参数的累加。如何校验这个函数呢？可以下面的代码进行最简单的校验
```
 if(add(1,2) !== 3){
  throw Error('add计算错误！');
 }
```
如果是用jasmine来描述我们上面的测试的话
```
describe("Calculator Operations", function () {
  it("Should add two numbers", function () {
    expect(add(1,2)).toBe(3);
  });
});
```
describe会创建一个测试套件——一组有关联性的测试单元的集合。上面的测试套件是跟计算相关的，因此我们还可以加入相减、相乘等测试操作。
使用 it 函数，我们用来描述我们正在测试的特性或功能片段。
expect 是测试断言，用来判断我们的代码是否如期运行。
### 有哪些测试流派？
#### TDD
TDD是Test Driven Development 的缩写，也就是测试驱动开发。
通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但是TDD要求我们在编写功能代码前先编写测试代码。
Tdd 过程包括以下步骤:
  1. 写一个单元测试去描述程序的一个方面。
  2. 运行它应该会失败，因为程序还缺少这个特性。
  3. 编写使测试通过所需的最小代码量
  4. 运行测试以检查新测试通过情况
  5. 可以选择重构代码
  6. 重复第一个步骤，重新完善测试代码
具体的实践可以看[[译]5步法让TDD变得简单](/[译]5步法让TDD变得简单.md)
#### BDD
BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。
行为驱动开发(BDD)是测试驱动开发(TDD)的一个分支。同样也是先写测试，再完成具体实现。Bdd 注重于测试行为，而不是实现。一个写得不好的测试将检查实现而不是行为。 如果实现随着应用程序的发展或重构而改变，那么即使行为相同，测试也必须改变。 这抵消了 TDD 节省时间的好处。

举一个计数器的例子。
```
suite('Counter', function() {
  test('tick increases count to 1', function() {
    var counter = new Counter();
 
    counter.tick();
 
    assert.equal(counter.count, 1);
  });
});
```
这是一个虚构的计数器对象的单元测试。我们测试在调用 tick 之后，这个值应该是1，这听起来很合理。 但是在测试中有一个问题。测试完全依赖于计数器从0开始这一事实。 所以换句话说，这个测试依赖于两件事情。
  1.  计数器从0开始
  2.  tick调用增量1
计数器从0开始是一个与 tick ()函数的行为无关的实现细节。因此，它不应该对测试有任何影响。我们这样编写测试的唯一原因是我们考虑的是实现，而不是行为。
Bdd 建议测试行为，所以我们不去考虑代码是如何实现的，而是花一点时间考虑场景是什么。 当tick调用时，它应该增加一个计数。
这里重要的部分是考虑场景，而不是实现，可以引导你设计一个更好的测试。
```
describe('Counter', function() {
  it('should increase count by 1 after calling tick', function() {
    var counter = new Counter();
    var expectedCount = counter.count + 1;

    counter.tick();

    assert.equal(counter.count, expectedCount);
  });
});
```
在这个版本的测试中，使用了 Mocha 的 BDD 风格函数，我们去掉了实现细节。我们不是依赖于从0开始的计数器，而是与 counter.count + 1进行比较，后者在测试行为方面更有意义。
有时候你的需求会改变。让我们想象一下，由于某种原因，计数器必须从其他值开始。在此之前，我们必须更改测试以适应这一点，但是对于BDD编写的测试代码而言，没有必要这样做。
### 有哪些常见的单元测试框架？
#### MochaJS
Mochajs 是最流行的支持后端和前端测试的测试框架。 Mochajs 是一个灵活的基础，可以根据需要开发测试。 它在 Chrome v 8引擎或其他浏览器上异步运行测试。
Mocha的优点包括:
  -  适用于前端和后端
  -  支持 node.js 调试器
  -  支持任何浏览器，包括无头 chrome 库
  -  支持mocking以进行灵活的后端测试
#### Jasmine
Jasmine 是一个测试 JavaScript 代码的（BDD）行为驱动开发框架。Jasmine 允许使用延迟和等待时间来自动化用户行为，以模拟实际的用户行为。
```
describe("A suite is just a function", function() {
  var a;

  it("and so is a spec", function() {
    a = true;

    expect(a).toBe(true);
  });
});
```
#### Ava
Ava 是一个简约的轻量级测试框架，利用了 Javascript 的异步特性。 Ava 可以并发地执行测试。它允许你几乎完全控制你所做的事情。 它用于基于 node.js 的代码测试。 
优点：
  -  异步和并发地运行测试
  -  比大多数其他测试框架都要快
  -  为检测到的任何潜在错误清理堆栈跟踪
#### JEST
Jest 是 Facebook 定期维护的最流行的框架之一。 它是基于 React 的应用程序的首选框架，因为它是零配置的。
然而，它不仅限于与 React 一起使用，vue-cli 的配置选项也有他。Jest 的一些特性如下:
  - 单一框架适用于 node.js，VueJS，React，Angular 和其他基于 Babel 的项目
  - 快手上手
  - 良好的文档和标准的编码语法
  - 使用 Live 快照，它允许管理较大对象的测试
#### Karma
Karma 是一个高效的测试环境，它支持所有流行的测试描述框架(Jasmine、 Mocha、 QUnit)。 它为您的应用程序提供在不同环境中执行测试的支持。 它支持在不同的设备和应用程序上执行测试。
选择 Karma 的主要因素在于它支持集成 CI/CD 引擎和以下特性。
  - 可用于在浏览器、PhantomJS 等headless环境以及设备上运行测试
  - 支持在大多数流行框架中编写的测试
  - 支持使用 Chrome 和 Webstorm 进行测试用例调试
#### Tape
Tape在架构上与 AVA 非常相似。 它不支持全局变量，因此需要在每个测试文件中包含磁带。 这个限制全局变量的决定也有它的好处。 其中一些特性最引人注目:
  - 不支持全局变量，提供纯粹的代码，让开发人员可以完全自由地编写测试用例
  - 支持 ES6、Typescript和coffee script 
  - 支持在大多数现代浏览器上执行测试
#### Cypress.io
Cypress 是一个令人兴奋的测试框架。它以网页的形式在浏览器上提供了一个交互式用户界面。 它可以很容易地安装在 Mac，Windows 和 Linux 上。它是一个独立的测试运行程序，不需要与您的代码紧密集成。
#### Puppeteer
Puppeteer 是 Google 团队构建的一个优秀的测试执行框架。它为 node.js 应用程序提供了一个 [headless chrome](https://developers.google.com/web/updates/2017/06/headless-karma-mocha-chai)API。
Pupteer 主要用于特定于浏览器的应用程序，如爬虫测试、页面结构测试、截图，甚至为单页应用程序捕获预渲染内容。 使用木偶师的其他好处包括:
  - 能够为浏览器设置自定义分辨率和大小
  - 表单提交、UI 测试和键盘输入的自动化支持
  - 支持诸如 await 和 async 之类的 ES6功能
#### ChaiJS
Chaijs 框架侧重于行为驱动的测试。 它可以与任何其他框架并行使用。它已经存在很长一段时间了，并且随着 Javascript 标准的演变而不断发展。
Chaijs 可以使用 Node、浏览器、 rails，并获得了很好的支持社区和文档。
#### Qunit
Qunit是一个强大的测试框架，致力于使用前端。 它是 JQuery、 JQuery Mobile 和 JQuery UI 库开发者的首选。
它可以作为一个独立的 JS 文件编写，并在任何网页上执行。 使用 Qunit 进行测试的标准方法是将文件放到网页上，并使用 Qunit 插件运行测试。 优点包括:
  - 可用于构建可重用的测试脚本
  - 提供可视化查看测试用例输出的即时部署 web 界面
  - 可以通过插件池更快的编写测试用例
#### Sinon
Sinon 主要用来伪造真实的数据。因为在测试期间——您不会得到所有的数据！ 它支持 Chrome，ie11，Firefox，Edge，Safari 和 Node.js 运行时。
另一个很好的选择是 [testdouble.js](https://github.com/testdouble/testdouble.js/)

参考文章
  - [11 Best JavaScript Unit Testing Framework and Tools](https://geekflare.com/javascript-unit-testing/)
  - [关于前端开发谈谈单元测试](https://segmentfault.com/a/1190000000317146)
  - [An introduction to frontend testing](https://www.creativebloq.com/how-to/an-introduction-to-frontend-testing)
  - [What’s the difference between Unit Testing, TDD and BDD?](https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/)