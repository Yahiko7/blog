> 本文将详细地分析创建作用域的过程。分析创建作用域的过程有助于我们理解一些概念，比如闭包和IIFEs(立即执行函数)。
## 执行上下文
执行上下文不是一个具体的东西，而是一个抽象的概念，它对于描述JavaScript编译和执行代码的过程的某些部分非常有用。虽然我们都知道JavaScript是一门解释性语言，但是浏览器执行JavaScript的过程是需要一个编译阶段的。
与作用域一样，只要浏览器加载脚本，我们就进入全局执行上下文，每次调用一个函数(即使递归调用相同的函数)，都会创建它自己的函数执行上下文。
JavaScript是单线程的，这意味着一次只能发生一件事。由于执行上下文是在嵌套函数中创建的，因此不能同时执行它们，因此将它们添加到所谓的执行上下文堆栈中，以等待轮到它们执行。
## 执行上下文堆栈
观察下面的代码：
```
function one() {
  function two() {
    //some code
    function three() {
      //some code
      console.log("We are in function three!");
    }
  }
}
```
在第10行执行到“We are in function three!”的时候，我们已经有4个执行上下文:
```
1. function three's Execution Context
-------------------------------------
3. function two's Execution Context
-------------------------------------
2. function one's Execution Context
-------------------------------------
1. Global Execution Context
-------------------------------------
```
堆栈是后进先出LIFO结构，这意味着 “最后入” 是 “第一个出”。因此，在创建了4个执行上下文之后，第一个要处理的上下文将是函数three()的上下文;第二个函数是function two();等等.
这样解释起来是很简单，但是当我们创建一个执行上下文时具体做了什么事情呢？
## 两个步骤
执行上下文的生命周期大体上缩减为两个步骤:
1. 创建阶段
2. 代码执行阶段
完成这两个步骤后，执行上下文被销毁，JavaScript的解释器(负责“读取”代码并处理代码的解释器)将继续处理堆栈中的下一个执行上下文。创建阶段与编译密切相关，因此，为了理解它，我们将了解一下JavaScript的编译器。
## JavaScript的编译过程
虽然我们常说JavaScript不是一种编译语言，而是一种解释语言。但这并不是因为JavaScript没有编译过程。JavaScript与其他传统编译语言的最大区别在于，JavaScript在执行代码之前会编译代码。JavaScript的编译过程包括通常由其他编程语言提前完成的常见步骤：
1. 分/词法分析 (Tokenizing / Lexing)：将一串代码分成若干块(标记)并赋予它们语义。例如，如果编译器遇到var some_variable = 1;，它会(在某些情况下)将这段代码分为var、some_variable、=、1和;。在JavaScript中，这些标记中的每一个都有不同的含义(对于上面的示例，关键字、变量名、赋值操作符、整数和分号)。也许在其他一些编程语言中，编译器会以其他方式分隔这些标记(例如，它可以确定空格也有意义)。标记和词法是同一个过程;区别在于它们用来决定如何将代码分隔为Tokenizing的规则。JavaScript使用词法分析，这意味着它使用有状态解析规则来实现其目的。
2. 语法分析（parsing）：创建一个名为AST(抽象语法树)的数据结构，它表示脚本的语法结构。AST是一个具有节点和边的树，它们显式地表示代码中标记之间存在的关系。
3. 代码生成（Code-Generation）：获取AST并将其转换为运行脚本的机器可以执行的代码。
当然，这个过程还包括其他步骤，但是这些步骤与我们的讨论最为相关。总的来说，我们可以说JavaScript的编译是这样一个过程:变量和函数被声明，词法范围被定义，this 关键字被分配。更确切地说，创建阶段发生在编译期间，它可以分为以下步骤：
1. 创建激活对象（Activation Object）
2. 创建参数对象（Arguments Object）
3. Scope赋值
4. 变量实例化
5. this关键字的赋值
让我们通过一个例子来分析这个问题:
```
var var1 = 1;
var var2 = 2;
 
function example(argument1, argument2) {
  var var3 = 3;
  
  function innerFunc() {
    var4 = 4;
    console.log(var1 + var2 + var3 + var4);
  }
  
  innerFunc();    
}
 
example(var1, var2); //10
```
在第15行执行example()时，我们进入上述函数的执行上下文并开始创建阶段。让我们看看每一步:
### 创建激活对象（Activation Object）
如果我们把执行上下文想象成一个JSON对象(记住，执行上下文只是一个抽象的概念，但是把它想象成一个具体的对象会有助于分析)，那么现在我们就会得到:
```
exampleExecutionContext = {
  activationObject = {}   
}
```
激活对象Activation Object当前为空。我们很快就会把它写满。
### 创建参数对象（Arguments Object）
arguments对象作为激活对象的属性创建。它是一个数组，包含传递给函数的参数及其对应长度:
```
exampleExecutionContext = {
  activationObject = {
    arguments: [
      {argument: 1, length: 1},
      {argument: 2, length: 1}
    ]
  }   
}
```
### Scope赋值
scope被赋值给当前执行上下文。这是通过查找父函数的作用域(在本例中是全局作用域)并将当前函数的作用域添加到父函数的作用域中来实现的。作用域的连接称为作用域链，它是一个数组，包含到目前为止积累的所有作用域，以便当前函数可以使用它们。每个范围都表示为一个变量对象Variable Object(VO)。变量对象是一个激活对象，它包含声明和分配的变量和函数。当前函数的变量对象被添加到其父作用域链的开头。
```
exampleExecutionContext = {
  activationObject = {
    arguments: [
      {argument: 1, length: 1},
      {argument: 2, length: 1}
    ]
  },
  scopeChain: [example function VO, global VO]
}
```
### 函数和变量的声明
